#!/usr/bin/env python

# netfiles.py - classes that understand various network config files

import sys, traceback, string, os

class ConfigFileBase(object):
    """base class for rest of specific config file classes"""
    filepath = ''
    lines = []

    def __init__(self, filepath):
        """initialize self from config file: simply read into memory"""
        self.filepath = filepath
        fin = open(filepath, 'r')
        self.lines = fin.readlines()
        fin.close()

    def __str__(self):
        """return entire config file as string"""
        return string.join(self.lines, '')

    def write(self, makeBackup = True):
        """rewrite the config file, perhaps making a backup of the old one"""
        if makeBackup:
            bakfilepath = self.filepath + '.bak'
            try: os.remove(bakfilepath)
            except: pass
            os.rename(self.filepath, bakfilepath)
        else:
            try: os.remove(self.filepath)
            except: pass
        fout = open(self.filepath, 'w')
        fout.writelines(self.lines)
        fout.close()

class EtcWvdialConf(ConfigFileBase):
    """wvdial configuration"""
    FILEPATH = '/etc/wvdial.conf.test'
    KEYS = set(['modem', 'phone', 'username', 'password', 'baud', \
            'idle seconds', 'init1', 'init2'])
    metadata = {}

    def __init__(self):
        """initialize self from config file, parsing out metadata"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        for line in self.lines:
            (key, value) = self._parse_line(line)
            if key in self.KEYS:
                self.metadata[key] = value

    def _parse_line(self, line):
        """parse out the interesting bits of one line"""
        eq = line.find('=')
        if eq > 0:
            key = line[0:eq].strip().lower()
            value = line[eq+1:].strip()
            return (key, value)
        return (None, None)

    def _update_lines(self):
        """return original list of lines updated by metadata"""
        newlines = []
        altered_keys = set()

        # alter existing lines that have metadata overrides
        for line in self.lines:
            (key, value) = self._parse_line(line)
            if self.metadata.has_key(key):
                line = "%s = %s\n" % (key, self.metadata[key])
                altered_keys.add(key)
            newlines.append(line)

        # add lines for metadata not yet existing in file
        meta_keys = set(self.metadata.keys())
        for key in meta_keys.difference(altered_keys):
            newlines.append("%s = %s\n" % (key, self.metadata[key]))
        return newlines

    def __str__(self):
        """return entire config file as string, modified by parsed content"""
        return string.join(self._update_lines())

    def write(self, makeBackup = True):
        """edit lines in memory, then write config file"""
        self.lines = self._update_lines()
        ConfigFileBase.write(self, makeBackup)

class mySubnetSection(object):
    """helper class for EtcDhcp3DhcpConf"""
    done = False
    subnet = None
    netmask = None
    start_ip = None
    end_ip = None
    options = {}

    # unbound class methods
    def begins(self, line):
        """answer whether this line begins a new section of interest"""
        tokens = line.split()
        return tokens and tokens[0].lower() == 'subnet'

    def ends(self, line):
        """answer whether this line ends a section of interest"""
        tokens = line.split()
        return '}' in set(tokens)

    def get_subnet(self, line):
        """return subnet parsed from first line of subnet section"""
        tokens = line.split()
        return tokens[1]

    # class instance methods
    def __init__(self, line):
        """initialize from first line of subnet section"""
        self.add_line(line)

    def add_line(self, line):
        """add line being parsed to a subnet"""
        tokens = line.split()
        if tokens:
            keyword = tokens[0].lower()
            if keyword == 'subnet':
                self.subnet = tokens[1]
                self.netmask = tokens[3]
            elif keyword == 'range':
                self.start_ip = tokens[1]
                self.end_ip = tokens[2].strip(';')
            elif keyword == 'option':
                key = tokens[1]
                value = tokens[2].strip(';')
                self.options[key] = value
            if '}' in set(tokens):
                done = True

    def lines(self):
        """return list of config lines generated by this section"""
        lines = []
        lines.append('subnet %s netmask %s {\n' % (self.subnet, self.netmask))
        lines.append('  range %s %s;\n' % (self.start_ip, self.end_ip))
        for key, value in self.options.iteritems():
            lines.append('  option %s %s;\n' % (key, value))
        lines.append('}\n')
        return lines

class EtcDhcp3DhcpConf(ConfigFileBase):
    """DHCP configuration"""
    FILEPATH = '/etc/dhcp3/dhcpd.conf'
    subnets = {}

    def __init__(self):
        """initialize self from config file, parsing out interesting content"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        section = None
        for line in self.lines:
            if section:
                section.add_line(line)
                if section.done:
                    self.subnets[section.subnet] = section
                    section = None
            elif mySubnetSection().begins(line):
                section = mySubnetSection(line)

    def _update_lines(self):
        """return original list of lines updated by metadata"""
        newlines = []
        subnet = None
        for line in self.lines:
            if subnet:
                if mySubnetSection().ends(line):
                    newlines.append(section.lines)
                    subnet = None
            elif mySubnetSection().begins(line):
                subnet = mySubnetSection().get_subnet(line)
            else:
                newlines.append(line)
        return newlines

    def __str__(self):
        """return entire config file as string, modified by parsed content"""
        return string.join(self._update_lines())

    def write(self, makeBackup = True):
        """edit lines in memory, then write config file"""
        self.lines = self._update_lines()
        ConfigFileBase.write(self, makeBackup)

class EtcNetworkInterfaces(ConfigFileBase):
    """network interfaces definitions"""
    FILEPATH = '/etc/network/interfaces'
    autoset = set()
    ifaces = {}

    def __init__(self):
        """initialize self from config file, parsing out interesting content"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        for line in self.lines:
            tokens = line.split()
            if tokens:
                keyword = tokens[0].lower()
                if keyword == 'auto':
                    self.autoset.update(tokens[1:])
                elif keyword == 'iface':
                    name = tokens[1]
                    self.ifaces[name] = self.iface_params = {}
                    self.iface_params['method'] = tokens[3]
                elif keyword in ['address', 'netmask', 'gateway']:
                    self.iface_params[keyword] = tokens[1]

    def write(self, makeBackup = True):
        """edit lines in memory, then write config file"""
        ConfigFileBase.write(self, makeBackup)

def main():
    """test these classes"""

    '''
    o = EtcWvdialConf()
    print o
    print "Metadata =", o.metadata
    print "==================================================="
    '''

    o = EtcDhcp3DhcpConf()
    print o
    print "Subnets =", o.subnets

    '''
    o = EtcNetworkInterfaces()
    print o
    print "Auto Start =", o.autoset
    print "Interfaces =", o.ifaces
    print "==================================================="
    '''

if __name__ == '__main__':
    main()
