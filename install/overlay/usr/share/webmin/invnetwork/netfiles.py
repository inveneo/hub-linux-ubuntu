#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
netfiles.py - classes that encapsulate various network config files

Copyright (c) 2007 Inveneo, inc. All rights reserved.
"""

import sys, traceback, string, os
sys.path.append('/opt/inveneo/lib/python')

class ConfigFileBase(object):
    """operations and data present in all config file managers"""
    filepath = ''
    lines = []

    def __init__(self, filepath):
        """initialize self from config file: simply read into memory"""
        self.filepath = filepath
        fin = open(filepath, 'r')
        self.lines = fin.readlines()
        fin.close()

    def write(self, makeBackup = True):
        """rewrite the config file, perhaps making a backup of the old one"""
        if makeBackup:
            bakfilepath = self.filepath + '.bak'
            try: os.remove(bakfilepath)
            except: pass
            os.rename(self.filepath, bakfilepath)
        else:
            try: os.remove(self.filepath)
            except: pass
        fout = open(self.filepath, 'w')
        fout.writelines(self.lines)
        fout.close()

class EtcWvdialConf(ConfigFileBase):
    """wvdial configuration"""
    FILEPATH = '/etc/wvdial.conf.test'
    KEYS = set(['modem', 'phone', 'username', 'password', 'baud', \
            'idle seconds', 'init1', 'init2'])
    metadata = {}

    def __init__(self):
        """initialize self from config file, parsing out metadata"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        for line in self.lines:
            (key, value) = self._parse_line(line)
            if key in self.KEYS:
                self.metadata[key] = value

    def _parse_line(self, line):
        """parse out the interesting bits of one line"""
        eq = line.find('=')
        if eq > 0:
            key = line[0:eq].strip().lower()
            value = line[eq+1:].strip()
            return (key, value)
        return (None, None)

    def _update_lines(self):
        """return original list of lines updated by metadata"""
        newlines = []
        found_keys = set()

        # alter existing lines that have metadata overrides
        for line in self.lines:
            (key, value) = self._parse_line(line)
            if self.metadata.has_key(key):
                line = "%s = %s\n" % (key, self.metadata[key])
                found_keys.add(key)
            newlines.append(line)

        # add lines for metadata not yet existing in file
        meta_keys = set(self.metadata.keys())
        for key in meta_keys.difference(found_keys):
            newlines.append("%s = %s\n" % (key, self.metadata[key]))
        return newlines

    def __str__(self):
        """return entire config file as string, modified by parsed content"""
        return string.join(self._update_lines(), '')

    def write(self, makeBackup = True):
        """rewrite the config file, perhaps making a backup of the old one"""
        self.lines = self._update_lines()
        ConfigFileBase.write(makeBackup)

class EtcDhcp3DhcpConf(ConfigFileBase):
    """DHCP configuration"""
    FILEPATH = '/etc/dhcp3/dhcpd.conf'
    subnets = {}

    class SubnetSection(object):
        """helper class for EtcDhcp3DhcpConf"""
        subnet = None
        netmask = None
        start_ip = None
        end_ip = None
        options = {}

        # static methods
        def begins(line):
            """answer whether this line begins a new section of interest"""
            tokens = line.split()
            return tokens and tokens[0].lower() == 'subnet'
        begins = staticmethod(begins)

        def ends(line):
            """answer whether this line ends a section of interest"""
            tokens = line.split()
            return '}' in set(tokens)
        ends = staticmethod(ends)

        def get_key(line):
            """return subnet parsed from first line of subnet section"""
            tokens = line.split()
            return tokens[1]
        get_key = staticmethod(get_key)

        # instance methods
        def __init__(self, line):
            """initialize from first line of subnet section"""
            self.add_line(line)

        def add_line(self, line):
            """add line of file to subnet section, return False on last line"""
            tokens = line.split()
            if tokens:
                keyword = tokens[0].lower()
                if keyword == 'subnet':
                    self.subnet = tokens[1]
                    self.netmask = tokens[3]
                elif keyword == 'range':
                    self.start_ip = tokens[1]
                    self.end_ip = tokens[2].strip(';')
                elif keyword == 'option':
                    key = tokens[1]
                    value = tokens[2].strip(';')
                    self.options[key] = value
                if '}' in set(tokens):
                    return False
            return True

        def lines(self):
            """return list of config lines generated by this section"""
            lines = []
            lines.append('subnet %s netmask %s {\n' % \
                    (self.subnet, self.netmask))
            if self.start_ip and self.end_ip:
                lines.append('  range %s %s;\n' % (self.start_ip, self.end_ip))
            for key, value in self.options.iteritems():
                lines.append('  option %s %s;\n' % (key, value))
            lines.append('}\n')
            return lines

        def __str__(self):
            """return single string representation of self"""
            return string.join(self.lines(), '')

    def __init__(self):
        """initialize self from config file, parsing out interesting content"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        section = None
        for line in self.lines:
            if section:
                if not section.add_line(line):
                    self.subnets[section.subnet] = section
                    section = None
            elif self.SubnetSection.begins(line):
                section = self.SubnetSection(line)

    def _update_lines(self):
        """return original list of lines updated by metadata"""
        newlines = []
        found_keys = set()

        # alter existing lines that have metadata overrides
        subnet = None
        for line in self.lines:
            if subnet:
                # we are inside a section: are we done yet?
                if self.SubnetSection.ends(line):
                    # insert metadata instead, if there is any
                    if self.subnets.has_key(subnet):
                        newlines.extend(self.subnets[subnet].lines())
                        found_keys.add(subnet)
                    subnet = None
            else:
                # not inside a section: is this the start of one?
                if self.SubnetSection.begins(line):
                    # yes: pluck out its name
                    subnet = self.SubnetSection.get_key(line)
                else:
                    # nope: just some random stuff to copy through
                    newlines.append(line)

        # add lines for metadata not yet existing in file
        keys = set(self.subnets.keys())
        for key in keys.difference(found_keys):
            newlines.extend(self.subnets[subnet].lines())

        return newlines

    def __str__(self):
        """return entire config file as string, modified by parsed content"""
        return string.join(self._update_lines(), '')

    def write(self, makeBackup = True):
        """rewrite the config file, perhaps making a backup of the old one"""
        self.lines = self._update_lines()
        ConfigFileBase.write(makeBackup)

class EtcNetworkInterfaces(ConfigFileBase):
    """network interfaces definitions"""
    FILEPATH = '/etc/network/interfaces'
    autoset = set()
    ifaces = {}

    def __init__(self):
        """initialize self from config file, parsing out interesting content"""
        ConfigFileBase.__init__(self, self.FILEPATH)
        for line in self.lines:
            tokens = line.split()
            if tokens:
                keyword = tokens[0].lower()
                if keyword == 'auto':
                    self.autoset.update(tokens[1:])
                elif keyword == 'iface':
                    name = tokens[1]
                    self.ifaces[name] = self.iface_params = {}
                    self.iface_params['method'] = tokens[3]
                elif keyword in ['address', 'netmask', 'gateway']:
                    self.iface_params[keyword] = tokens[1]

def main():
    """test these classes"""

    print "==================================================="
    print "Parsing /etc/wvdial.conf"
    print "==================================================="
    o = EtcWvdialConf()
    print "Metadata =", o.metadata
    print o

    print "==================================================="
    print "Parsing /etc/dhcp3/dhcp.conf"
    print "==================================================="
    o = EtcDhcp3DhcpConf()
    print "Subnets =", o.subnets
    print o

    '''
    print "==================================================="
    print "Parsing /etc/network/interfaces"
    print "==================================================="
    o = EtcNetworkInterfaces()
    print "Auto Start =", o.autoset
    print "Interfaces =", o.ifaces
    print o
    '''

if __name__ == '__main__':
    main()
